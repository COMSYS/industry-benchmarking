# Key Generation for Company Uploads

We try to use a root CA which is generated by the analyst. He uploads this root CA to be trusted by the server.
The analyst signs the public keys of the companies that registered and gets their certificates.
He uploads them to the server which should accept all root CA signed certificates.

## Generate the root CA

1. Generate the private key of the root CA.
```bash
openssl genrsa -out rootCAKey.key 2048
```

2. Create a *self-signed* root CA certificate from the private key.
```bash
openssl req -x509 -sha256 -new -nodes -key rootCAKey.key -days 3650 -out rootCACert.pem
```

3. Review the content of the Root CA key
```bash
openssl x509 -in rootCACert.pem -text
```  

This root CA is used for the server to accept all other certificates that have been signed. 

## Generate CA-signed client certificates for companies

These keys are the companies keys. They first need to generate them and later send them to the analyst who signs them.
Then the `RootCertStore` in `rustls` should accept all the certificates that are uploaded to it.

1. Generate the private key of the company.
```bash
openssl genrsa -out company00.key 2048
```

2. Create a *Certificate Signing Request (CSR)* as an intermediary step before the public key can be signed.
```bash
openssl req -new -key company00.key -out company00.csr
```
`rustls`'s implementation of `ClientCertVerifier` “will ensure that every client provides a trusted certificate, without any name checking.” This means that no SAN is required!

3. Define `openssl x509` extensions for the client certificate. See also [`openssl x509` man page](https://www.openssl.org/docs/manmaster/man5/x509v3_config.html).

```
[root@server keys]# cat client_cert_ext.cnf
---------------
basicConstraints = CA:FALSE
nsCertType = client, email
nsComment = "OpenSSL Generated Client Certificate"
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer
keyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = clientAuth, emailProtection
--------------
basicConstraints      : An end user certificate must either set CA to FALSE or exclude the extension entirely
nsCertType            : This is Netscape Certificate Type which consists of a list of flags to be included. 
                        Acceptable values for nsCertType are: client, server, email, objsign, reserved, sslCA, emailCA, objCA
nsComment             : Netscape Comment (nsComment) is a string extension containing a comment which will be displayed 
                        when the certificate is viewed in some browsers.
subjectKeyIdentifier  : This is really a string extension and can take two possible values. Either the word hash which will 
                        automatically follow the guidelines in RFC3280 or a hex string giving the extension value to include.
authorityKeyIdentifier: The authority key identifier extension permits two options. keyid and issuer: both can take the optional value "always".
keyUsage              : Key usage is a multi valued extension consisting of a list of names of the permitted key usages.
extendedKeyUsage      : This extensions consists of a list of usages indicating purposes for which the certificate public key can be used for,
```

4. Create the client certificate using the CA key and the Certificate Signing Request as well as the configuration from the previous step. 
```
openssl x509 -req -in company00.csr -CA rootCACert.pem -CAkey rootCAKey.key -CAcreateserial -out company00.cert.pem -days 365 -sha256 -extfile client_cert_ext.cnf
```

This certificate file is uploaded by the analyst. This results in the server accepting exactly the companies incoming traffic.

### Use client certificate in company Browser

In order to use the certificate as a client certificate, the browser (or any other HTTP-client) requires the certificate and key to use it accordingly.
For this reason, the certificate, and key need to be exported to a PFX file.
A PFX file is a certificate in PKCS#12 format; it contains the certificate, the intermediate authority certificate necessary for the trustworthiness of the certificate, and the private key to the certificate. 
It is like an archive that stores everything you need to deploy a certificate.

1. Create PFX certificate file. The companies should protect it with a password as losing it is critical for access. 
```bash
openssl pkcs12 -export -in company00.cert.pem -inkey company00.key -out company00.pfx
```

2. Import into Chromium (or similar application): Settings → Data Privacy & Security → Security → Manage certificates → My Certificates → Import

3. Go to website and call link accordingly.

# Generating TLS keys for server TLS 

- This step is required in testing environment, as the key is normally generated in the enclave
- To generate your public and private keys use the installed `openssl` package:
    - First generate the private key of desired length (here RSA 4096 bits)
    - Then calculate the public key from the generated private key
    - Create a Certificate Signing Request to get a certificate
    - Sign the public key with your private key to create a (self-signed) certificate

1. Generate a key pair
``` bash
# RSA key pair
openssl genrsa -out server.key 4096
openssl rsa -in server.key -pubout > server.pem
```
2. Sign the key pair or use signed ones
```bash
# Create a CSR certification authority for the public key
openssl req -new -key server.key -out server.csr
# Self sign certificate
openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.pem
```

- The keys you should have a specified SAN to enable trust from clients. This is usually not a problem in private scenarios.
